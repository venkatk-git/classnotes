[
  {
    "title": "Introduction to Tree Algorithms",
    "author": "Nathan Chen, Siyong Huang, Albert Ye",
    "description": "Introducing a special type of graph - trees\r",
    "body": {
      "raw": "\r\n<br />\r\n\r\n**Trees** are generally treated very differently from general graph problems.\r\n\r\nSome properties/definitions of trees:\r\n\r\n-   A graph is a **tree** iff it is connected and contains $N$ nodes and $N-1$\r\n    edges\r\n-   A graph is a **tree** iff every pair of nodes has exactly one simple path\r\n    between them\r\n-   A graph is a **tree** iff it is connected and does not contain any cycles\r\n\r\nGeneral Tree Terminology:\r\n\r\n-   A **leaf** of a tree is any node in the tree with degree $1$\r\n    -   If the tree is rooted, the **root** with a single child is _not_ typically\r\n        considered a leaf, but depending on the problem, this is not always the case\r\n-   A **star graph** has two common definitions. Try to understand what they\r\n    mean - they typically appear in subtasks.\r\n    -   Definition 1: Only one node has degree greater than $1$\r\n    -   Definition 2: Only one node has degree greater than $2$\r\n-   A **forest** is a graph such that each **connected component** is a tree\r\n\r\nRooted Tree Terminology:\r\n\r\n-   A **root** of a tree is any node of the tree that is considered to be at the\r\n    'top'\r\n-   A **parent** of a node $n$ is the first node along the path from $n$ to the\r\n    **root**\r\n    -   The **root** does not have a **parent**. This is typically done in code by\r\n        setting the **parent** of the **root** to be $-1$.\r\n-   The **ancestors** of a node are its **parent** and **parent's** **ancestors**\r\n    -   Typically, a node is considered its own ancestor as well (such as in the\r\n        subtree definition)\r\n-   The **subtree** of a node $n$ are the set of nodes that have $n$ as an\r\n    ancestor\r\n    -   A node is typically considered to be in its own subtree\r\n    -   Note: This is easily confused with **subgraph**\r\n-   The **depth**, or **level**, of a node is its distance from the root\r\n\r\n## Solution - Subordinates\r\n\r\nIn this problem we are given the parent of each node of a rooted tree, and we\r\nwant to compute the subtree size for each node. A subtree is composed of a root\r\nnode and the subtrees of the root's children. Thus, the size of a subtree is one\r\nplus the size of the root's childrens' subtrees.\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Subordinates {\r\n\tstatic InputReader in = new InputReader(System.in);\r\n\tstatic PrintWriter out = new PrintWriter(System.out);\r\n\r\n\tpublic static final int MN = 200020;\r\n\r\n\tstatic int N, M, ans;\r\n\tstatic int[] hd = new int[MN], nx = new int[MN], to = new int[MN], s = new int[MN],\r\n\t             p = new int[MN];\r\n\r\n\tpublic static void adde(int u, int v, int id) {\r\n\t\tnx[id] = hd[u];\r\n\t\thd[u] = id;\r\n\t\tto[id] = v;\r\n\t}\r\n\tpublic static void dfs(int node) {\r\n\t\ts[node] = 1;\r\n\t\tfor (int id = hd[node]; id != 0; id = nx[id]) {\r\n\t\t\tdfs(to[id]);\r\n\t\t\ts[node] += s[to[id]];\r\n\t\t}\r\n\t}\r\n\tpublic static void main(String... args) {\r\n\t\tN = in.nextInt();\r\n\t\tfor (int i = 2; i <= N; ++i) {\r\n\t\t\tp[i] = in.nextInt();\r\n\t\t\tadde(p[i], i, i);\r\n\t\t}\r\n\t\tdfs(1);\r\n\t\tfor (int i = 1; i <= N; ++i) {\r\n\t\t\tout.print(s[i] - 1);\r\n\t\t\tif (i < N) out.print(\" \");\r\n\t\t\telse out.println();\r\n\t\t}\r\n\t\tout.close();\r\n\t}\r\n}\r\n```\r\n",
      "code": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var y=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),b=(t,n)=>{for(var r in n)o(t,r,{get:n[r],enumerable:!0})},d=(t,n,r,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of g(n))!m.call(t,i)&&i!==r&&o(t,i,{get:()=>n[i],enumerable:!(s=u(n,i))||s.enumerable});return t};var w=(t,n,r)=>(r=t!=null?p(f(t)):{},d(n||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),$=t=>d(o({},\"__esModule\",{value:!0}),t);var a=y((v,l)=>{l.exports=_jsx_runtime});var x={};b(x,{default:()=>c,frontmatter:()=>N});var e=w(a()),N={title:\"Introduction to Tree Algorithms\",author:\"Nathan Chen, Siyong Huang, Albert Ye\",description:\"Introducing a special type of graph - trees\"};function h(t){let n={code:\"code\",em:\"em\",h2:\"h2\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...t.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(\"br\",{}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Trees\"}),\" are generally treated very differently from general graph problems.\"]}),`\n`,(0,e.jsx)(n.p,{children:\"Some properties/definitions of trees:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"A graph is a \",(0,e.jsx)(n.strong,{children:\"tree\"}),` iff it is connected and contains $N$ nodes and $N-1$\\r\nedges`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A graph is a \",(0,e.jsx)(n.strong,{children:\"tree\"}),` iff every pair of nodes has exactly one simple path\\r\nbetween them`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A graph is a \",(0,e.jsx)(n.strong,{children:\"tree\"}),\" iff it is connected and does not contain any cycles\"]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"General Tree Terminology:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"leaf\"}),\" of a tree is any node in the tree with degree $1$\",`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"If the tree is rooted, the \",(0,e.jsx)(n.strong,{children:\"root\"}),\" with a single child is \",(0,e.jsx)(n.em,{children:\"not\"}),` typically\\r\nconsidered a leaf, but depending on the problem, this is not always the case`]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"star graph\"}),` has two common definitions. Try to understand what they\\r\nmean - they typically appear in subtasks.`,`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Definition 1: Only one node has degree greater than $1$\"}),`\n`,(0,e.jsx)(n.li,{children:\"Definition 2: Only one node has degree greater than $2$\"}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"forest\"}),\" is a graph such that each \",(0,e.jsx)(n.strong,{children:\"connected component\"}),\" is a tree\"]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"Rooted Tree Terminology:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"root\"}),` of a tree is any node of the tree that is considered to be at the\\r\n'top'`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"parent\"}),` of a node $n$ is the first node along the path from $n$ to the\\r\n`,(0,e.jsx)(n.strong,{children:\"root\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"The \",(0,e.jsx)(n.strong,{children:\"root\"}),\" does not have a \",(0,e.jsx)(n.strong,{children:\"parent\"}),`. This is typically done in code by\\r\nsetting the `,(0,e.jsx)(n.strong,{children:\"parent\"}),\" of the \",(0,e.jsx)(n.strong,{children:\"root\"}),\" to be $-1$.\"]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"The \",(0,e.jsx)(n.strong,{children:\"ancestors\"}),\" of a node are its \",(0,e.jsx)(n.strong,{children:\"parent\"}),\" and \",(0,e.jsx)(n.strong,{children:\"parent's\"}),\" \",(0,e.jsx)(n.strong,{children:\"ancestors\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:`Typically, a node is considered its own ancestor as well (such as in the\\r\nsubtree definition)`}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"The \",(0,e.jsx)(n.strong,{children:\"subtree\"}),` of a node $n$ are the set of nodes that have $n$ as an\\r\nancestor`,`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"A node is typically considered to be in its own subtree\"}),`\n`,(0,e.jsxs)(n.li,{children:[\"Note: This is easily confused with \",(0,e.jsx)(n.strong,{children:\"subgraph\"})]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[\"The \",(0,e.jsx)(n.strong,{children:\"depth\"}),\", or \",(0,e.jsx)(n.strong,{children:\"level\"}),\", of a node is its distance from the root\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Solution - Subordinates\"}),`\n`,(0,e.jsx)(n.p,{children:`In this problem we are given the parent of each node of a rooted tree, and we\\r\nwant to compute the subtree size for each node. A subtree is composed of a root\\r\nnode and the subtrees of the root's children. Thus, the size of a subtree is one\\r\nplus the size of the root's childrens' subtrees.`}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-java\",children:`import java.io.*;\\r\nimport java.util.*;\\r\n\\r\npublic class Subordinates {\\r\n\tstatic InputReader in = new InputReader(System.in);\\r\n\tstatic PrintWriter out = new PrintWriter(System.out);\\r\n\\r\n\tpublic static final int MN = 200020;\\r\n\\r\n\tstatic int N, M, ans;\\r\n\tstatic int[] hd = new int[MN], nx = new int[MN], to = new int[MN], s = new int[MN],\\r\n\t             p = new int[MN];\\r\n\\r\n\tpublic static void adde(int u, int v, int id) {\\r\n\t\tnx[id] = hd[u];\\r\n\t\thd[u] = id;\\r\n\t\tto[id] = v;\\r\n\t}\\r\n\tpublic static void dfs(int node) {\\r\n\t\ts[node] = 1;\\r\n\t\tfor (int id = hd[node]; id != 0; id = nx[id]) {\\r\n\t\t\tdfs(to[id]);\\r\n\t\t\ts[node] += s[to[id]];\\r\n\t\t}\\r\n\t}\\r\n\tpublic static void main(String... args) {\\r\n\t\tN = in.nextInt();\\r\n\t\tfor (int i = 2; i <= N; ++i) {\\r\n\t\t\tp[i] = in.nextInt();\\r\n\t\t\tadde(p[i], i, i);\\r\n\t\t}\\r\n\t\tdfs(1);\\r\n\t\tfor (int i = 1; i <= N; ++i) {\\r\n\t\t\tout.print(s[i] - 1);\\r\n\t\t\tif (i < N) out.print(\" \");\\r\n\t\t\telse out.println();\\r\n\t\t}\\r\n\t\tout.close();\\r\n\t}\\r\n}\n`})})]})}function c(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,{...t,children:(0,e.jsx)(h,{...t})}):h(t)}return $(x);})();\n;return Component;"
    },
    "_id": "java/intro-trees.mdx",
    "_raw": {
      "sourceFilePath": "java/intro-trees.mdx",
      "sourceFileName": "intro-trees.mdx",
      "sourceFileDir": "java",
      "contentType": "mdx",
      "flattenedPath": "java/intro-trees"
    },
    "type": "Java",
    "slug": "/java/intro-trees",
    "slugAsParams": "intro-trees"
  }
]