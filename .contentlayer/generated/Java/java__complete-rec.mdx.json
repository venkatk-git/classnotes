{
  "title": "Complete Search with Recursion",
  "author": "Many",
  "description": "Harder problems involving iterating through the entire solution space, including those that require generating subsets and permutations.\r",
  "body": {
    "raw": "\r\n## Subsets\r\n\r\n### Resources\r\n\r\n### Solution - Apple Division\r\n\r\nSince $n \\le 20$, we can solve this by trying all possible divisions\r\nof $n$ apples into two sets and finding the one with the minimum difference in\r\nweights. Here are two ways to do this.\r\n\r\n#### Generating Subsets Recursively\r\n\r\nThe first method would be to write a recursive function which searches over all\r\npossibilities.\r\n\r\nThen, we return the difference between the two sums once we've reached the end\r\nof the array.\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class AppleDivision {\r\n\tstatic int n;\r\n\tstatic int[] weights;\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tKattio io = new Kattio();\r\n\r\n\t\tn = io.nextInt();\r\n\t\tweights = new int[n];\r\n\t\tfor (int i = 0; i < n; i++) { weights[i] = io.nextInt(); }\r\n\r\n\t\t// Solve the problem starting at apple 0 with both sets being empty\r\n\t\tio.println(recurseApples(0, 0, 0));\r\n\t\tio.close();\r\n\t}\r\n\r\n\tstatic long recurseApples(int index, long sum1, long sum2) {\r\n\t\t// We've added all apples- return the absolute difference\r\n\t\tif (index == n) { return Math.abs(sum1 - sum2); }\r\n\r\n\t\t// Try adding the current apple to either the first or second set\r\n\t\treturn Math.min(recurseApples(index + 1, sum1 + weights[index], sum2),\r\n\t\t                recurseApples(index + 1, sum1, sum2 + weights[index]));\r\n\t}\r\n\r\n\t// CodeSnip{Kattio}\r\n}\r\n```\r\n\r\n#### Generating Subsets with Bitmasks\r\n\r\n## Warning\r\n\r\nA **bitmask** is an integer whose binary representation is used to represent a\r\nsubset. In the context of this problem, if the $i$'th bit is equal to $1$ in a particular bitmask,\r\nwe say the $i$'th apple is in $s_1$. If not, we'll say it's in $s_2$.\r\nWe can iterate through all subsets $s_1$ if we check all bitmasks ranging from\r\n$0$ to $2^N-1$.\r\n\r\nLet's do a quick demo with $N=3$.\r\nThese are the integers from $0$ to $2^3-1$ along with their\r\nbinary representations and the corresponding elements included in $s_1$.\r\nAs you can see, all possible subsets are accounted for.\r\n\r\n<center>\r\n\r\n<table>\r\n<thead>\r\n    <tr>\r\n        <td>Number</td>\r\n        <td>Binary</td>\r\n        <td>Apples In $s_1$</td>\r\n    </tr>\r\n</thead>\r\n<tbody>\r\n    <tr>\r\n        <td>0</td>\r\n        <td>`000`</td>\r\n        <td>$\\{\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>1</td>\r\n        <td>`001`</td>\r\n        <td>$\\{0\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>2</td>\r\n        <td>`010`</td>\r\n        <td>$\\{1\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>3</td>\r\n        <td>`011`</td>\r\n        <td>$\\{0,1\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>4</td>\r\n        <td>`100`</td>\r\n        <td>$\\{2\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>5</td>\r\n        <td>`101`</td>\r\n        <td>$\\{0,2\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>6</td>\r\n        <td>`110`</td>\r\n        <td>$\\{1,2\\}$</td>\r\n    </tr>\r\n    <tr>\r\n        <td>7</td>\r\n        <td>`111`</td>\r\n        <td>$\\{0,1,2\\}$</td>\r\n    </tr>\r\n</tbody>\r\n</table>\r\n</center>\r\n\r\nWith this concept, we can implement our solution.\r\n\r\nYou'll notice that our code contains some fancy bitwise operations:\r\n\r\n-   `1 << x` for an integer $x$ is another way of writing $2^x$, which, in binary,\r\n    has only the $x$'th bit turned on.\r\n-   The `&` (AND) operator will take two integers and return a new integer.\r\n    `a & b` for integers $a$ and $b$ will return a new integer whose $i$th bit is\r\n    turned on if and only if the $i$'th bit is turned on for both $a$ and $b$.\r\n    Thus, `mask & (1 << x)` will return a positive value only if the $x$'th bit is\r\n    turned on in $mask$.\r\n\r\nIf you wanna learn more about them, we have a\r\n[dedicated module](/silver/intro-bitwise) for bitwise operations.\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class AppleDivision {\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tKattio io = new Kattio();\r\n\r\n\t\tint n = io.nextInt();\r\n\t\tint[] weights = new int[n];\r\n\t\tfor (int i = 0; i < n; i++) { weights[i] = io.nextInt(); }\r\n\r\n\t\tlong ans = Long.MAX_VALUE;\r\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\r\n\t\t\tlong sum1 = 0;\r\n\t\t\tlong sum2 = 0;\r\n\t\t\tfor (int i = 0; i < n; i++) {\r\n\t\t\t\t// Check if the ith bit is toggled\r\n\t\t\t\tif ((mask & (1 << i)) > 0) {\r\n\t\t\t\t\t// If it is, the apple is included in sum1\r\n\t\t\t\t\tsum1 += weights[i];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsum2 += weights[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tans = Math.min(ans, Math.abs(sum1 - sum2));\r\n\t\t}\r\n\r\n\t\tio.println(ans);\r\n\t\tio.close();\r\n\t}\r\n\r\n\t// CodeSnip{Kattio}\r\n}\r\n```\r\n\r\n## Permutations\r\n\r\nA **permutation** is a reordering of a list of elements.\r\n\r\n### Lexicographical Order\r\n\r\nThis term is mentioned quite frequently, ex. in\r\n[USACO Bronze - Photoshoot](http://www.usaco.org/index.php?page=viewproblem2&cpid=988).\r\n\r\nThink about how are words ordered in a dictionary. (In fact, this is where the\r\nterm \"lexicographical\" comes from.)\r\n\r\nIn dictionaries, you will see that words beginning with the letter `a` appears\r\nat the very beginning, followed by words beginning with `b`, and so on. If two\r\nwords have the same starting letter, the second letter is used to compare them;\r\nif both the first and second letters are the same, then use the third letter to\r\ncompare them, and so on until we either reach a letter that is different, or we\r\nreach the end of some word (in this case, the shorter word goes first).\r\n\r\nPermutations can be placed into lexicographical order in almost the same way. We\r\nfirst group permutations by their first element; if the first element of two\r\npermutations are equal, then we compare them by the second element; if the\r\nsecond element is also equal, then we compare by the third element, and so on.\r\n\r\nFor example, the permutations of 3 elements, in lexicographical order, are\r\n\r\n$$\r\n[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\r\n$$\r\n\r\nNotice that the list starts with permutations beginning with 1 (just like a\r\ndictionary that starts with words beginning with `a`), followed by those\r\nbeginning with 2 and those beginning with 3. Within the same starting element,\r\nthe second element is used to make comparisions.\r\n\r\nGenerally, unless you are specifically asked to find the lexicographically\r\nsmallest/largest solution, you do not need to worry about whether permutations\r\nare being generated in lexicographical order. However, the idea of\r\nlexicographical order does appear quite often in programming contest problems,\r\nand in a variety of contexts, so it is strongly recommended that you familiarize\r\nyourself with its definition.\r\n\r\nSome problems will ask for an ordering of elements that satisfies certain\r\nconditions. In these problems, if $N \\leq 10$, we can just iterate through all\r\n$N!=N\\cdot (N-1)\\cdot (N-2)\\cdots 1$ permutations and check each permutation for\r\nvalidity.\r\n\r\n### Solution - Creating Strings I\r\n\r\n#### Generating Permutations Recursively\r\n\r\nThis is just a slight modification of method 1 from CPH.\r\n\r\nWe'll use the recursive function to find all the permutations\r\nof the string $s$. First, keep track of how many of each character there are in\r\n$s$. For each function call, add an available character to the current string,\r\nand call with that string. When the current string has the\r\nsame size as $s$, we've found a permutation and can add it to the list.\r\n\r\n```java\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class CreatingStrings1 {\r\n\tstatic String s;\r\n\tstatic List<String> perms = new ArrayList<String>();\r\n\tstatic int[] charCount = new int[26];\r\n\r\n\tstatic void search(String curr) {\r\n\t\t// We've finished creating a permutation\r\n\t\tif (curr.length() == s.length()) {\r\n\t\t\tperms.add(curr);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfor (int i = 0; i < 26; i++) {\r\n\t\t\t// For all available characters\r\n\t\t\tif (charCount[i] > 0) {\r\n\t\t\t\t// Add it to the current string and continue the search\r\n\t\t\t\tcharCount[i]--;\r\n\t\t\t\tsearch(curr + (char)(i + 'a'));\r\n\t\t\t\tcharCount[i]++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void main(String[] args) throws IOException {\r\n\t\tKattio io = new Kattio();\r\n\t\ts = io.next();\r\n\r\n\t\tfor (int i = 0; i < s.length(); i++) { charCount[s.charAt(i) - 'a']++; }\r\n\r\n\t\tsearch(\"\");\r\n\r\n\t\tio.println(perms.size());\r\n\t\tfor (String perm : perms) { io.println(perm); }\r\n\t\tio.close();\r\n\t}\r\n\r\n\t// CodeSnip{Kattio}\r\n}\r\n```\r\n\r\n#### Generating Permutations Using [`next_permutation`](https://en.cppreference.com/w/cpp/algorithm/next_permutation)\r\n\r\nAlternatively, we can just use the `next_permutation()` function. This function\r\ntakes in a range and modifies it to the next greater permutation. If there is no\r\ngreater permutation, it returns false. To iterate through all permutations,\r\nplace it inside a `do-while` loop. We are using a `do-while` loop here instead\r\nof a typical `while` loop because a `while` loop would modify the smallest\r\npermutation before we got a chance to process it.\r\n\r\nWhat's going to be in the `check` function depends on the problem, but it should\r\nverify whether the current permutation satisfies the constraints given in the\r\nproblem.\r\n\r\nEach call to `next_permutation` makes a constant number of swaps on average if\r\nwe go through all $N!$ permutations of size $N$.\r\n\r\n## Warning\r\n\r\nOne small detail is that you need to sort the string before calling\r\n`next_permutation()` because the method generates strings in lexicographical\r\norder. If the string isn't sorted, then strings which are lexicographically\r\nsmaller than the initial string won't be generated.\r\n\r\n#### Generating Permutations Using [`itertools.permutations`](https://docs.python.org/3/library/itertools.html#itertools.permutations)\r\n\r\nSince `itertools.permutations` treats elements as unique based on position, not\r\nvalue, it returns all permutations, with repeats. Putting the returned tuples in\r\na set can filter out duplicates, and since tuples are returned, we need to join\r\nthe characters into a string.\r\n\r\n#### By Generating Permutations\r\n\r\nA brute-force solution that checks all $\\binom{64}{8}$ possible queen\r\ncombinations will have over 4 billion arrangements to check, making it too slow.\r\n\r\nWe have to brute-force a bit smarter:\r\nnotice that we can directly generate permutations so that no two queens are\r\nattacking each other due to being in the same row or column.\r\n\r\nSince no two queens can be in the same column, it makes sense\r\nto lay one out in each row.\r\nIt remains to figure out how to vary the _rows_ each queen is in.\r\nThis can be done by generating all permutations from $1 \\cdots 8$, with the\r\nnumbers representing which row each queen is in.\r\n\r\nFor example, the permutation $[6, 0, 5, 1, 4, 3, 7, 2]$ results in this\r\nqueen arrangement:\r\n\r\n<table className=\"text-center\">\r\n    <tbody>\r\n        <tr>\r\n            <td></td>\r\n            <td>0</td>\r\n            <td>1</td>\r\n            <td>2</td>\r\n            <td>3</td>\r\n            <td>4</td>\r\n            <td>5</td>\r\n            <td>6</td>\r\n            <td>7</td>\r\n        </tr>\r\n        <tr>\r\n            <td>0</td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>1</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>2</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n        </tr>\r\n        <tr>\r\n            <td>3</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>4</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>5</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>6</td>\r\n            <td>Q</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n        </tr>\r\n        <tr>\r\n            <td>7</td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td></td>\r\n            <td>Q</td>\r\n            <td></td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n\r\nDoing this cuts down the number of arrangements we have to check down to\r\na much more managable $8!$.\r\n\r\n```java\r\nimport java.io.*;\r\n\r\npublic class ChessboardQueens {\r\n\tprivate static final int DIM = 8;\r\n\r\n\tprivate static boolean[][] blocked = new boolean[DIM][DIM];\r\n\r\n\tprivate static final boolean[] rowsTaken = new boolean[DIM];\r\n\t// Indicators for diagonals that go from the bottom left to the top right\r\n\tprivate static final boolean[] diag1 = new boolean[DIM * 2 - 1];\r\n\t// Indicators for diagonals that go from the bottom right to the top left\r\n\tprivate static final boolean[] diag2 = new boolean[DIM * 2 - 1];\r\n\r\n\tprivate static int validNum = 0;\r\n\r\n\tpublic static void main(String[] args) throws Exception {\r\n\t\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\r\n\t\tfor (int r = 0; r < DIM; r++) {\r\n\t\t\tString row = read.readLine();\r\n\t\t\tfor (int c = 0; c < DIM; c++) {\r\n\t\t\t\tif (row.charAt(c) == '*') { blocked[r][c] = true; }\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsearchQueens(0);\r\n\r\n\t\tSystem.out.println(validNum);\r\n\t}\r\n\r\n\tprivate static void searchQueens(int c) {\r\n\t\tif (c == DIM) {\r\n\t\t\t// We've filled all rows, increment and return\r\n\t\t\tvalidNum++;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfor (int r = 0; r < DIM; r++) {\r\n\t\t\tboolean row_open = !rowsTaken[r];\r\n\t\t\tboolean diag_open = !diag1[r + c] && !diag2[r - c + DIM - 1];\r\n\t\t\tif (!blocked[r][c] && row_open && diag_open) {\r\n\t\t\t\t// A row and two diagonals have been taken\r\n\t\t\t\trowsTaken[r] = diag1[r + c] = diag2[r - c + DIM - 1] = true;\r\n\t\t\t\tsearchQueens(c + 1);\r\n\t\t\t\t// And now they aren't anymore\r\n\t\t\t\trowsTaken[r] = diag1[r + c] = diag2[r - c + DIM - 1] = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n## Problems\r\n\r\nYou can find more problems at the CP2 link given above or at\r\n[USACO Training](https://train.usaco.org/). However, these sorts of problems\r\nappear much less frequently than they once did.\r\n",
    "code": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},d=(n,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!w.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(a=p(e,i))||a.enumerable});return n};var $=(n,e,r)=>(r=n!=null?u(g(n)):{},d(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),v=n=>d(o({},\"__esModule\",{value:!0}),n);var h=f((I,s)=>{s.exports=_jsx_runtime});var x={};b(x,{default:()=>c,frontmatter:()=>y});var t=$(h()),y={title:\"Complete Search with Recursion\",author:\"Many\",description:\"Harder problems involving iterating through the entire solution space, including those that require generating subsets and permutations.\"};function l(n){let e={a:\"a\",code:\"code\",em:\"em\",h2:\"h2\",h3:\"h3\",h4:\"h4\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Subsets\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Resources\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Solution - Apple Division\"}),`\n`,(0,t.jsx)(e.p,{children:`Since $n \\\\le 20$, we can solve this by trying all possible divisions\\r\nof $n$ apples into two sets and finding the one with the minimum difference in\\r\nweights. Here are two ways to do this.`}),`\n`,(0,t.jsx)(e.h4,{children:\"Generating Subsets Recursively\"}),`\n`,(0,t.jsx)(e.p,{children:`The first method would be to write a recursive function which searches over all\\r\npossibilities.`}),`\n`,(0,t.jsx)(e.p,{children:`Then, we return the difference between the two sums once we've reached the end\\r\nof the array.`}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-java\",children:`import java.io.*;\\r\nimport java.util.*;\\r\n\\r\npublic class AppleDivision {\\r\n\tstatic int n;\\r\n\tstatic int[] weights;\\r\n\\r\n\tpublic static void main(String[] args) throws Exception {\\r\n\t\tKattio io = new Kattio();\\r\n\\r\n\t\tn = io.nextInt();\\r\n\t\tweights = new int[n];\\r\n\t\tfor (int i = 0; i < n; i++) { weights[i] = io.nextInt(); }\\r\n\\r\n\t\t// Solve the problem starting at apple 0 with both sets being empty\\r\n\t\tio.println(recurseApples(0, 0, 0));\\r\n\t\tio.close();\\r\n\t}\\r\n\\r\n\tstatic long recurseApples(int index, long sum1, long sum2) {\\r\n\t\t// We've added all apples- return the absolute difference\\r\n\t\tif (index == n) { return Math.abs(sum1 - sum2); }\\r\n\\r\n\t\t// Try adding the current apple to either the first or second set\\r\n\t\treturn Math.min(recurseApples(index + 1, sum1 + weights[index], sum2),\\r\n\t\t                recurseApples(index + 1, sum1, sum2 + weights[index]));\\r\n\t}\\r\n\\r\n\t// CodeSnip{Kattio}\\r\n}\n`})}),`\n`,(0,t.jsx)(e.h4,{children:\"Generating Subsets with Bitmasks\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Warning\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.strong,{children:\"bitmask\"}),` is an integer whose binary representation is used to represent a\\r\nsubset. In the context of this problem, if the $i$'th bit is equal to $1$ in a particular bitmask,\\r\nwe say the $i$'th apple is in $s_1$. If not, we'll say it's in $s_2$.\\r\nWe can iterate through all subsets $s_1$ if we check all bitmasks ranging from\\r\n$0$ to $2^N-1$.`]}),`\n`,(0,t.jsx)(e.p,{children:`Let's do a quick demo with $N=3$.\\r\nThese are the integers from $0$ to $2^3-1$ along with their\\r\nbinary representations and the corresponding elements included in $s_1$.\\r\nAs you can see, all possible subsets are accounted for.`}),`\n`,(0,t.jsx)(\"center\",{children:(0,t.jsxs)(\"table\",{children:[(0,t.jsx)(\"thead\",{children:(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"Number\"}),(0,t.jsx)(\"td\",{children:\"Binary\"}),(0,t.jsx)(\"td\",{children:\"Apples In $s_1$\"})]})}),(0,t.jsxs)(\"tbody\",{children:[(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"0\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"000\"})}),(0,t.jsx)(\"td\",{children:\"${}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"1\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"001\"})}),(0,t.jsx)(\"td\",{children:\"${0}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"2\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"010\"})}),(0,t.jsx)(\"td\",{children:\"${1}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"3\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"011\"})}),(0,t.jsx)(\"td\",{children:\"${0,1}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"4\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"100\"})}),(0,t.jsx)(\"td\",{children:\"${2}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"5\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"101\"})}),(0,t.jsx)(\"td\",{children:\"${0,2}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"6\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"110\"})}),(0,t.jsx)(\"td\",{children:\"${1,2}$\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"7\"}),(0,t.jsx)(\"td\",{children:(0,t.jsx)(e.code,{children:\"111\"})}),(0,t.jsx)(\"td\",{children:\"${0,1,2}$\"})]})]})]})}),`\n`,(0,t.jsx)(e.p,{children:\"With this concept, we can implement our solution.\"}),`\n`,(0,t.jsx)(e.p,{children:\"You'll notice that our code contains some fancy bitwise operations:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"1 << x\"}),` for an integer $x$ is another way of writing $2^x$, which, in binary,\\r\nhas only the $x$'th bit turned on.`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"&\"}),` (AND) operator will take two integers and return a new integer.\\r\n`,(0,t.jsx)(e.code,{children:\"a & b\"}),` for integers $a$ and $b$ will return a new integer whose $i$th bit is\\r\nturned on if and only if the $i$'th bit is turned on for both $a$ and $b$.\\r\nThus, `,(0,t.jsx)(e.code,{children:\"mask & (1 << x)\"}),` will return a positive value only if the $x$'th bit is\\r\nturned on in $mask$.`]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[`If you wanna learn more about them, we have a\\r\n`,(0,t.jsx)(e.a,{href:\"/silver/intro-bitwise\",children:\"dedicated module\"}),\" for bitwise operations.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-java\",children:`import java.io.*;\\r\nimport java.util.*;\\r\n\\r\npublic class AppleDivision {\\r\n\tpublic static void main(String[] args) throws Exception {\\r\n\t\tKattio io = new Kattio();\\r\n\\r\n\t\tint n = io.nextInt();\\r\n\t\tint[] weights = new int[n];\\r\n\t\tfor (int i = 0; i < n; i++) { weights[i] = io.nextInt(); }\\r\n\\r\n\t\tlong ans = Long.MAX_VALUE;\\r\n\t\tfor (int mask = 0; mask < (1 << n); mask++) {\\r\n\t\t\tlong sum1 = 0;\\r\n\t\t\tlong sum2 = 0;\\r\n\t\t\tfor (int i = 0; i < n; i++) {\\r\n\t\t\t\t// Check if the ith bit is toggled\\r\n\t\t\t\tif ((mask & (1 << i)) > 0) {\\r\n\t\t\t\t\t// If it is, the apple is included in sum1\\r\n\t\t\t\t\tsum1 += weights[i];\\r\n\t\t\t\t} else {\\r\n\t\t\t\t\tsum2 += weights[i];\\r\n\t\t\t\t}\\r\n\t\t\t}\\r\n\t\t\tans = Math.min(ans, Math.abs(sum1 - sum2));\\r\n\t\t}\\r\n\\r\n\t\tio.println(ans);\\r\n\t\tio.close();\\r\n\t}\\r\n\\r\n\t// CodeSnip{Kattio}\\r\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Permutations\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.strong,{children:\"permutation\"}),\" is a reordering of a list of elements.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Lexicographical Order\"}),`\n`,(0,t.jsxs)(e.p,{children:[`This term is mentioned quite frequently, ex. in\\r\n`,(0,t.jsx)(e.a,{href:\"http://www.usaco.org/index.php?page=viewproblem2&cpid=988\",children:\"USACO Bronze - Photoshoot\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:`Think about how are words ordered in a dictionary. (In fact, this is where the\\r\nterm \"lexicographical\" comes from.)`}),`\n`,(0,t.jsxs)(e.p,{children:[\"In dictionaries, you will see that words beginning with the letter \",(0,t.jsx)(e.code,{children:\"a\"}),` appears\\r\nat the very beginning, followed by words beginning with `,(0,t.jsx)(e.code,{children:\"b\"}),`, and so on. If two\\r\nwords have the same starting letter, the second letter is used to compare them;\\r\nif both the first and second letters are the same, then use the third letter to\\r\ncompare them, and so on until we either reach a letter that is different, or we\\r\nreach the end of some word (in this case, the shorter word goes first).`]}),`\n`,(0,t.jsx)(e.p,{children:`Permutations can be placed into lexicographical order in almost the same way. We\\r\nfirst group permutations by their first element; if the first element of two\\r\npermutations are equal, then we compare them by the second element; if the\\r\nsecond element is also equal, then we compare by the third element, and so on.`}),`\n`,(0,t.jsx)(e.p,{children:\"For example, the permutations of 3 elements, in lexicographical order, are\"}),`\n`,(0,t.jsx)(e.p,{children:`$$\\r\n[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1].\\r\n$$`}),`\n`,(0,t.jsxs)(e.p,{children:[`Notice that the list starts with permutations beginning with 1 (just like a\\r\ndictionary that starts with words beginning with `,(0,t.jsx)(e.code,{children:\"a\"}),`), followed by those\\r\nbeginning with 2 and those beginning with 3. Within the same starting element,\\r\nthe second element is used to make comparisions.`]}),`\n`,(0,t.jsx)(e.p,{children:`Generally, unless you are specifically asked to find the lexicographically\\r\nsmallest/largest solution, you do not need to worry about whether permutations\\r\nare being generated in lexicographical order. However, the idea of\\r\nlexicographical order does appear quite often in programming contest problems,\\r\nand in a variety of contexts, so it is strongly recommended that you familiarize\\r\nyourself with its definition.`}),`\n`,(0,t.jsx)(e.p,{children:`Some problems will ask for an ordering of elements that satisfies certain\\r\nconditions. In these problems, if $N \\\\leq 10$, we can just iterate through all\\r\n$N!=N\\\\cdot (N-1)\\\\cdot (N-2)\\\\cdots 1$ permutations and check each permutation for\\r\nvalidity.`}),`\n`,(0,t.jsx)(e.h3,{children:\"Solution - Creating Strings I\"}),`\n`,(0,t.jsx)(e.h4,{children:\"Generating Permutations Recursively\"}),`\n`,(0,t.jsx)(e.p,{children:\"This is just a slight modification of method 1 from CPH.\"}),`\n`,(0,t.jsx)(e.p,{children:`We'll use the recursive function to find all the permutations\\r\nof the string $s$. First, keep track of how many of each character there are in\\r\n$s$. For each function call, add an available character to the current string,\\r\nand call with that string. When the current string has the\\r\nsame size as $s$, we've found a permutation and can add it to the list.`}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-java\",children:`import java.io.*;\\r\nimport java.util.*;\\r\n\\r\npublic class CreatingStrings1 {\\r\n\tstatic String s;\\r\n\tstatic List<String> perms = new ArrayList<String>();\\r\n\tstatic int[] charCount = new int[26];\\r\n\\r\n\tstatic void search(String curr) {\\r\n\t\t// We've finished creating a permutation\\r\n\t\tif (curr.length() == s.length()) {\\r\n\t\t\tperms.add(curr);\\r\n\t\t\treturn;\\r\n\t\t}\\r\n\t\tfor (int i = 0; i < 26; i++) {\\r\n\t\t\t// For all available characters\\r\n\t\t\tif (charCount[i] > 0) {\\r\n\t\t\t\t// Add it to the current string and continue the search\\r\n\t\t\t\tcharCount[i]--;\\r\n\t\t\t\tsearch(curr + (char)(i + 'a'));\\r\n\t\t\t\tcharCount[i]++;\\r\n\t\t\t}\\r\n\t\t}\\r\n\t}\\r\n\\r\n\tpublic static void main(String[] args) throws IOException {\\r\n\t\tKattio io = new Kattio();\\r\n\t\ts = io.next();\\r\n\\r\n\t\tfor (int i = 0; i < s.length(); i++) { charCount[s.charAt(i) - 'a']++; }\\r\n\\r\n\t\tsearch(\"\");\\r\n\\r\n\t\tio.println(perms.size());\\r\n\t\tfor (String perm : perms) { io.println(perm); }\\r\n\t\tio.close();\\r\n\t}\\r\n\\r\n\t// CodeSnip{Kattio}\\r\n}\n`})}),`\n`,(0,t.jsxs)(e.h4,{children:[\"Generating Permutations Using \",(0,t.jsx)(e.a,{href:\"https://en.cppreference.com/w/cpp/algorithm/next_permutation\",children:(0,t.jsx)(e.code,{children:\"next_permutation\"})})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Alternatively, we can just use the \",(0,t.jsx)(e.code,{children:\"next_permutation()\"}),` function. This function\\r\ntakes in a range and modifies it to the next greater permutation. If there is no\\r\ngreater permutation, it returns false. To iterate through all permutations,\\r\nplace it inside a `,(0,t.jsx)(e.code,{children:\"do-while\"}),\" loop. We are using a \",(0,t.jsx)(e.code,{children:\"do-while\"}),` loop here instead\\r\nof a typical `,(0,t.jsx)(e.code,{children:\"while\"}),\" loop because a \",(0,t.jsx)(e.code,{children:\"while\"}),` loop would modify the smallest\\r\npermutation before we got a chance to process it.`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"What's going to be in the \",(0,t.jsx)(e.code,{children:\"check\"}),` function depends on the problem, but it should\\r\nverify whether the current permutation satisfies the constraints given in the\\r\nproblem.`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Each call to \",(0,t.jsx)(e.code,{children:\"next_permutation\"}),` makes a constant number of swaps on average if\\r\nwe go through all $N!$ permutations of size $N$.`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Warning\"}),`\n`,(0,t.jsxs)(e.p,{children:[`One small detail is that you need to sort the string before calling\\r\n`,(0,t.jsx)(e.code,{children:\"next_permutation()\"}),` because the method generates strings in lexicographical\\r\norder. If the string isn't sorted, then strings which are lexicographically\\r\nsmaller than the initial string won't be generated.`]}),`\n`,(0,t.jsxs)(e.h4,{children:[\"Generating Permutations Using \",(0,t.jsx)(e.a,{href:\"https://docs.python.org/3/library/itertools.html#itertools.permutations\",children:(0,t.jsx)(e.code,{children:\"itertools.permutations\"})})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Since \",(0,t.jsx)(e.code,{children:\"itertools.permutations\"}),` treats elements as unique based on position, not\\r\nvalue, it returns all permutations, with repeats. Putting the returned tuples in\\r\na set can filter out duplicates, and since tuples are returned, we need to join\\r\nthe characters into a string.`]}),`\n`,(0,t.jsx)(e.h4,{children:\"By Generating Permutations\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A brute-force solution that checks all $\\\\binom\",64,8,`$ possible queen\\r\ncombinations will have over 4 billion arrangements to check, making it too slow.`]}),`\n`,(0,t.jsx)(e.p,{children:`We have to brute-force a bit smarter:\\r\nnotice that we can directly generate permutations so that no two queens are\\r\nattacking each other due to being in the same row or column.`}),`\n`,(0,t.jsxs)(e.p,{children:[`Since no two queens can be in the same column, it makes sense\\r\nto lay one out in each row.\\r\nIt remains to figure out how to vary the `,(0,t.jsx)(e.em,{children:\"rows\"}),` each queen is in.\\r\nThis can be done by generating all permutations from $1 \\\\cdots 8$, with the\\r\nnumbers representing which row each queen is in.`]}),`\n`,(0,t.jsx)(e.p,{children:`For example, the permutation $[6, 0, 5, 1, 4, 3, 7, 2]$ results in this\\r\nqueen arrangement:`}),`\n`,(0,t.jsx)(\"table\",{className:\"text-center\",children:(0,t.jsxs)(\"tbody\",{children:[(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"0\"}),(0,t.jsx)(\"td\",{children:\"1\"}),(0,t.jsx)(\"td\",{children:\"2\"}),(0,t.jsx)(\"td\",{children:\"3\"}),(0,t.jsx)(\"td\",{children:\"4\"}),(0,t.jsx)(\"td\",{children:\"5\"}),(0,t.jsx)(\"td\",{children:\"6\"}),(0,t.jsx)(\"td\",{children:\"7\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"0\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"1\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"2\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"3\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"4\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"5\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"6\"}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{})]}),(0,t.jsxs)(\"tr\",{children:[(0,t.jsx)(\"td\",{children:\"7\"}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{}),(0,t.jsx)(\"td\",{children:\"Q\"}),(0,t.jsx)(\"td\",{})]})]})}),`\n`,(0,t.jsx)(e.p,{children:`Doing this cuts down the number of arrangements we have to check down to\\r\na much more managable $8!$.`}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-java\",children:`import java.io.*;\\r\n\\r\npublic class ChessboardQueens {\\r\n\tprivate static final int DIM = 8;\\r\n\\r\n\tprivate static boolean[][] blocked = new boolean[DIM][DIM];\\r\n\\r\n\tprivate static final boolean[] rowsTaken = new boolean[DIM];\\r\n\t// Indicators for diagonals that go from the bottom left to the top right\\r\n\tprivate static final boolean[] diag1 = new boolean[DIM * 2 - 1];\\r\n\t// Indicators for diagonals that go from the bottom right to the top left\\r\n\tprivate static final boolean[] diag2 = new boolean[DIM * 2 - 1];\\r\n\\r\n\tprivate static int validNum = 0;\\r\n\\r\n\tpublic static void main(String[] args) throws Exception {\\r\n\t\tBufferedReader read = new BufferedReader(new InputStreamReader(System.in));\\r\n\t\tfor (int r = 0; r < DIM; r++) {\\r\n\t\t\tString row = read.readLine();\\r\n\t\t\tfor (int c = 0; c < DIM; c++) {\\r\n\t\t\t\tif (row.charAt(c) == '*') { blocked[r][c] = true; }\\r\n\t\t\t}\\r\n\t\t}\\r\n\\r\n\t\tsearchQueens(0);\\r\n\\r\n\t\tSystem.out.println(validNum);\\r\n\t}\\r\n\\r\n\tprivate static void searchQueens(int c) {\\r\n\t\tif (c == DIM) {\\r\n\t\t\t// We've filled all rows, increment and return\\r\n\t\t\tvalidNum++;\\r\n\t\t\treturn;\\r\n\t\t}\\r\n\\r\n\t\tfor (int r = 0; r < DIM; r++) {\\r\n\t\t\tboolean row_open = !rowsTaken[r];\\r\n\t\t\tboolean diag_open = !diag1[r + c] && !diag2[r - c + DIM - 1];\\r\n\t\t\tif (!blocked[r][c] && row_open && diag_open) {\\r\n\t\t\t\t// A row and two diagonals have been taken\\r\n\t\t\t\trowsTaken[r] = diag1[r + c] = diag2[r - c + DIM - 1] = true;\\r\n\t\t\t\tsearchQueens(c + 1);\\r\n\t\t\t\t// And now they aren't anymore\\r\n\t\t\t\trowsTaken[r] = diag1[r + c] = diag2[r - c + DIM - 1] = false;\\r\n\t\t\t}\\r\n\t\t}\\r\n\t}\\r\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Problems\"}),`\n`,(0,t.jsxs)(e.p,{children:[`You can find more problems at the CP2 link given above or at\\r\n`,(0,t.jsx)(e.a,{href:\"https://train.usaco.org/\",children:\"USACO Training\"}),`. However, these sorts of problems\\r\nappear much less frequently than they once did.`]})]})}function c(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(l,{...n})}):l(n)}return v(x);})();\n;return Component;"
  },
  "_id": "java/complete-rec.mdx",
  "_raw": {
    "sourceFilePath": "java/complete-rec.mdx",
    "sourceFileName": "complete-rec.mdx",
    "sourceFileDir": "java",
    "contentType": "mdx",
    "flattenedPath": "java/complete-rec"
  },
  "type": "Java",
  "slug": "/java/complete-rec",
  "slugAsParams": "complete-rec"
}